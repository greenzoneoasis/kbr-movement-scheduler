<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Movement Scheduler with Supabase</title>
    <!--
      This version of the movement scheduler demonstrates how to persist data to
      a remote Supabase database instead of the browser's localStorage. The
      original app stored users, requests, movements and invitations directly
      in the user's browser. That meant each browser had its own copy of the
      data and an admin couldn't see requests created on another device. By
      moving persistence to Supabase we centralise our state so that every
      client sees the same information.  Use your own Supabase project URL
      and anon key below – you can find these in the Supabase dashboard. The
      Supabase JavaScript client is imported via CDN as described in the
      official documentation【830261165282000†L46-L63】.
    -->
    <style>
      /*
        ===== Modern styling =====

        These rules refresh the look and feel of the movement scheduler.
        The goal is to create a polished, contemporary aesthetic using a
        restrained colour palette, generous spacing and smooth gradients.
      */

      /* Page layout */
      body {
        font-family: 'Poppins', sans-serif;
        margin: 0;
        padding: 60px 0;
        /* soft gradient background for subtle depth */
        background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
        display: flex;
        justify-content: center;
      }

      /* Container: central panel with rounded corners and drop shadow */
      .container {
        width: 100%;
        max-width: 700px;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.05);
        padding: 30px 40px;
        text-align: center;
      }

      /* Logos container styling */
      .logos {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 20px;
      }
      .logos img {
        height: 60px;
      }

      /* Form and input styles */
      form {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
        margin-bottom: 30px;
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
      }

      /* Inputs and selects: spacious, rounded and subtle border */
      input,
      select {
        padding: 12px 14px;
        font-size: 15px;
        border-radius: 8px;
        border: 1px solid #d1d9e6;
        background: #ffffff;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      input:focus,
      select:focus {
        outline: none;
        border-color: #0070f3;
        box-shadow: 0 0 0 3px rgba(0, 112, 243, 0.15);
      }

      /* Buttons: gradient backgrounds and smooth hover transitions */
      button {
        padding: 12px;
        font-size: 15px;
        border-radius: 8px;
        border: none;
        background: linear-gradient(90deg, #0070f3 0%, #005bb5 100%);
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.3s, transform 0.1s;
      }
      button:hover {
        background: linear-gradient(90deg, #005bb5 0%, #004299 100%);
      }
      button:active {
        transform: translateY(1px);
      }

      /* Tabs: pill‑style segmented control */
      .tabs {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 30px;
      }
      .tabs button {
        flex: 1;
        padding: 12px;
        border-radius: 8px;
        background: #f5f7fa;
        border: none;
        font-size: 15px;
        font-weight: 600;
        color: #495057;
      }
      .tabs button.active {
        background: linear-gradient(90deg, #0070f3 0%, #005bb5 100%);
        color: #ffffff;
      }

      /* Tables: remove borders and add zebra striping */
      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
      }
      th,
      td {
        padding: 12px 16px;
        font-size: 14px;
      }
      th {
        background: #f5f7fa;
        font-weight: 600;
        text-align: left;
      }
      tr:nth-child(even) td {
        background: #fafbfc;
      }

      /* Messages */
      .error {
        color: #d32f2f;
        font-size: 14px;
        margin-top: 10px;
      }

    </style>
    <!-- React and Supabase dependencies. We rely on the global `supabase`
         variable after loading the client via CDN as described in the Supabase
         docs【830261165282000†L46-L63】. -->
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body>
    <div class="container">
      <!-- Application root -->
      <div id="root"></div>
    </div>
    <script>
      // Replace the placeholders below with your Supabase project credentials.
      // You can create a new project at https://app.supabase.com and find
      // the anonymous public key in your project settings. The Supabase
      // client is created once and reused throughout the application.
      const { createClient } = supabase;
      const SUPABASE_URL = 'YOUR_SUPABASE_URL';
      const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';
      const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      // Hard-coded admin credentials. These are added to the database on
      // startup if no admin user exists. In a production system you'd want
      // to manage admins differently.
      const ADMIN_EMAIL = 'haider.sahib@greenzone-oasis.com';
      const ADMIN_PASSWORD = 'Npsfaa@k3s';

      // Derive a name from an email address by capitalising each segment
      const deriveName = email => {
        return email
          .split('@')[0]
          .split('.')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join(' ');
      };

      function App() {
        // Authentication and global state
        const [user, setUser] = React.useState(null);
        const [loginEmail, setLoginEmail] = React.useState('');
        const [loginPassword, setLoginPassword] = React.useState('');
        const [error, setError] = React.useState('');
        const [activeTab, setActiveTab] = React.useState('request');
        const [requests, setRequests] = React.useState([]);
        const [movements, setMovements] = React.useState([]);
        // Form state holds the details for a new movement request.  We use a
        // single `route` string rather than separate `fromLocation` and
        // `toLocation` fields.  The route corresponds to one of the allowed
        // journeys (e.g. "BEC → BDSC").
        const [formData, setFormData] = React.useState({
          fullName: '',
          position: '',
          date: '',
          time: '',
          route: ''
        });
        const [usersList, setUsersList] = React.useState([]);
        const [invites, setInvites] = React.useState([]);
        // Invitation form state
        const [showInviteForm, setShowInviteForm] = React.useState(false);
        const [inviteEmail, setInviteEmail] = React.useState('');
        const [inviteMessage, setInviteMessage] = React.useState('');
        // Sign‑up via invite state
        const [signUpPassword, setSignUpPassword] = React.useState('');
        const [signUpConfirm, setSignUpConfirm] = React.useState('');

        // If the URL contains ?invite=email@address then this is an invited
        // user attempting to set their password.
        const inviteEmailParam = React.useMemo(() => {
          const params = new URLSearchParams(window.location.search);
          return params.get('invite');
        }, []);

        // On first render fetch all persisted data from Supabase. Also ensure
        // that the admin user exists; if not, insert it. Because Supabase
        // operations are asynchronous, we wrap them in an async function.
        React.useEffect(() => {
          (async () => {
            try {
              // Check for an existing admin
              const { data: existingAdmin } = await db
                .from('users')
                .select('*')
                .eq('email', ADMIN_EMAIL)
                .maybeSingle();
              if (!existingAdmin) {
                await db.from('users').insert([
                  {
                    name: deriveName(ADMIN_EMAIL),
                    email: ADMIN_EMAIL,
                    password: ADMIN_PASSWORD,
                    role: 'admin'
                  }
                ]);
              }
              // Fetch all users
              const { data: userRows } = await db.from('users').select('*');
              setUsersList(userRows || []);
              // Fetch requests
              const { data: reqRows } = await db.from('requests').select('*');
              setRequests(reqRows || []);
              // Fetch movements
              const { data: movRows } = await db.from('movements').select('*');
              setMovements(movRows || []);
              // Fetch invites
              const { data: inviteRows } = await db.from('invites').select('*');
              setInvites(inviteRows || []);
            } catch (err) {
              console.error('Error initialising data', err);
            }
          })();
        }, []);

        // Handle login
        async function handleLogin(e) {
          e.preventDefault();
          setError('');
          const { data: foundUser } = await db
            .from('users')
            .select('*')
            .eq('email', loginEmail.trim().toLowerCase())
            .eq('password', loginPassword)
            .maybeSingle();
          if (foundUser) {
            setUser(foundUser);
            setLoginEmail('');
            setLoginPassword('');
            setActiveTab(foundUser.role === 'admin' ? 'admin' : 'request');
          } else {
            setError('Invalid credentials');
          }
        }

        // Logout simply clears the user state
        function logout() {
          setUser(null);
          setActiveTab('request');
        }

        // Handle changes in the request form
        function handleFormChange(e) {
          const { name, value } = e.target;
          setFormData(prev => ({ ...prev, [name]: value }));
        }

        // Submit a new movement request and persist to Supabase
        async function submitRequest(e) {
          e.preventDefault();
          // Build the request object without an id – Supabase will generate one
          const newReq = {
            fullName: formData.fullName,
            position: formData.position,
            date: formData.date,
            time: formData.time,
            // Persist the selected route (e.g. "BEC → BDSC").  When using a
            // single route field the database only needs one text column.
            route: formData.route,
            status: 'pending'
          };
          const { data: inserted, error: insertErr } = await db
            .from('requests')
            .insert([newReq])
            .select();
          if (!insertErr && inserted && inserted.length > 0) {
            // Update local state with the new request
            setRequests(prev => [...prev, inserted[0]]);
            // Reset the form.  Since we only have a single route field, we
            // clear it here instead of from/to pairs.
            setFormData({
              fullName: '',
              position: '',
              date: '',
              time: '',
              route: ''
            });
          } else {
            console.error('Failed to insert request', insertErr);
          }
        }

        // Approve a pending request: update its status and add it to movements
        async function approveRequest(id) {
          // Find the original request object in state
          const req = requests.find(r => r.id === id);
          if (!req) return;
          // Update request status in the database
          const { data: updatedReqs, error: updateErr } = await db
            .from('requests')
            .update({ status: 'approved' })
            .eq('id', id)
            .select();
          // Insert corresponding movement
          // Build a movement object from the request.  Because requests now
          // store a single route string (e.g. "BEC → BDSC"), movements also
          // persist the route directly rather than separate from/to fields.
          const movement = {
            fullName: req.fullName,
            position: req.position,
            date: req.date,
            time: req.time,
            route: req.route,
            status: 'scheduled'
          };
          const { data: insertedMov, error: movErr } = await db
            .from('movements')
            .insert([movement])
            .select();
          if (!updateErr && !movErr) {
            // Update local state
            setRequests(prev => prev.map(r => (r.id === id ? { ...r, status: 'approved' } : r)));
            if (insertedMov && insertedMov.length > 0) {
              setMovements(prev => [...prev, insertedMov[0]]);
            }
          } else {
            console.error('Approval error', updateErr || movErr);
          }
        }

        // Decline a pending request by updating its status
        async function declineRequest(id) {
          const { error: updateErr } = await db
            .from('requests')
            .update({ status: 'declined' })
            .eq('id', id);
          if (!updateErr) {
            setRequests(prev => prev.map(r => (r.id === id ? { ...r, status: 'declined' } : r)));
          } else {
            console.error('Decline error', updateErr);
          }
        }

        // Handle the admin sending an invitation. This writes a new invite row
        // and returns a link the admin can email to the prospective user.
        async function handleInviteSubmit(e) {
          e.preventDefault();
          setInviteMessage('');
          const email = inviteEmail.trim().toLowerCase();
          if (!email) {
            setInviteMessage('Please provide a valid email.');
            return;
          }
          // Check if user already exists
          const { data: existingUser } = await db
            .from('users')
            .select('id')
            .eq('email', email)
            .maybeSingle();
          if (existingUser) {
            setInviteMessage('User already exists.');
            setInviteEmail('');
            setShowInviteForm(false);
            return;
          }
          // Check if an invitation is already recorded
          const { data: existingInvite } = await db
            .from('invites')
            .select('id')
            .eq('email', email)
            .maybeSingle();
          if (existingInvite) {
            setInviteMessage('An invitation has already been sent to this email.');
            setInviteEmail('');
            setShowInviteForm(false);
            return;
          }
          // Record the invitation
          const { data: insertedInv, error: invErr } = await db
            .from('invites')
            .insert([{ email: email, invited: true }])
            .select();
          if (!invErr && insertedInv && insertedInv.length > 0) {
            setInvites(prev => [...prev, insertedInv[0]]);
            const linkQuery = '?invite=' + encodeURIComponent(email);
            const invitationLink = window.location.origin + linkQuery;
            setInviteMessage('Invitation recorded. Please email the recipient this link: ' + invitationLink);
            setInviteEmail('');
            setShowInviteForm(false);
          } else {
            console.error('Invite error', invErr);
          }
        }

        // Handle an invited user setting their password. Creates a new user and
        // deletes the invite.
        async function handleInviteSignup(e) {
          e.preventDefault();
          setError('');
          if (signUpPassword !== signUpConfirm) {
            setError('Passwords do not match');
            return;
          }
          const email = inviteEmailParam.trim().toLowerCase();
          // Ensure the user doesn't already exist
          const { data: existingUser } = await db
            .from('users')
            .select('*')
            .eq('email', email)
            .maybeSingle();
          if (existingUser) {
            setError('Account already exists. Please log in instead.');
            return;
          }
          const newUser = {
            name: deriveName(email),
            email: email,
            password: signUpPassword,
            role: 'client'
          };
          const { error: insertErr } = await db.from('users').insert([newUser]);
          if (!insertErr) {
            // Delete the invite
            await db.from('invites').delete().eq('email', email);
            // Redirect back to login
            window.location.href = window.location.origin;
          } else {
            console.error('Signup error', insertErr);
            setError('Error creating account');
          }
        }

        // Compute derived lists
        const pendingRequests = requests.filter(r => r.status === 'pending');
        const scheduledMovements = movements;

        // If the user is not logged in we show either the invitation sign‑up
        // form or the login form.
        if (!user) {
          if (inviteEmailParam) {
            return (
              <div>
                <h2>Set Your Password</h2>
                <p>Please set a password for your new account ({inviteEmailParam}).</p>
                <form onSubmit={handleInviteSignup}>
                  <input
                    type="password"
                    placeholder="Enter Password"
                    value={signUpPassword}
                    onChange={e => setSignUpPassword(e.target.value)}
                    required
                  />
                  <input
                    type="password"
                    placeholder="Re‑Enter Password"
                    value={signUpConfirm}
                    onChange={e => setSignUpConfirm(e.target.value)}
                    required
                  />
                  {error && <div className="error">{error}</div>}
                  <button type="submit">Set Password</button>
                </form>
              </div>
            );
          }
          return (
            <div>
              <h2>Login</h2>
              <form onSubmit={handleLogin}>
                <input
                  type="email"
                  placeholder="Email"
                  value={loginEmail}
                  onChange={e => setLoginEmail(e.target.value)}
                  required
                />
                <input
                  type="password"
                  placeholder="Password"
                  value={loginPassword}
                  onChange={e => setLoginPassword(e.target.value)}
                  required
                />
                {error && <div className="error">{error}</div>}
                <button type="submit">Login</button>
              </form>
            </div>
          );
        }

        // Build the tab bar based on the user's role
        const tabs =
          user.role === 'admin'
            ? [
                { id: 'admin', label: 'Admin Review' },
                { id: 'agenda', label: 'Agenda' },
                { id: 'users', label: 'Users' }
              ]
            : [
                { id: 'request', label: 'Request Movement' },
                { id: 'agenda', label: 'Agenda' }
              ];

        const displayName = user.name || deriveName(user.email);

        return (
          <div>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <h2>Welcome, {displayName}</h2>
              <button onClick={logout}>Log Out</button>
            </div>
            <div className="tabs">
              {tabs.map(tab => (
                <button
                  key={tab.id}
                  className={activeTab === tab.id ? 'active' : ''}
                  onClick={() => setActiveTab(tab.id)}
                >
                  {tab.label}
                </button>
              ))}
            </div>

            {activeTab === 'request' && (
              <div>
                <h3>Request Movement</h3>
                <form onSubmit={submitRequest}>
                  <input
                    type="text"
                    name="fullName"
                    placeholder="Full Name"
                    value={formData.fullName}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="text"
                    name="position"
                    placeholder="Position"
                    value={formData.position}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="date"
                    name="date"
                    value={formData.date}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="time"
                    name="time"
                    value={formData.time}
                    onChange={handleFormChange}
                    required
                  />
                  {/* Route dropdown replaces separate from/to inputs.  Each
                      option encodes a full journey. */}
                  <label>Route</label>
                  <select
                    name="route"
                    value={formData.route}
                    onChange={handleFormChange}
                    required
                  >
                    <option value="">Select a route</option>
                    <option value="BEC → BDSC">BEC → BDSC</option>
                    <option value="BDSC → BEC">BDSC → BEC</option>
                    <option value="Union III → BDSC">Union III → BDSC</option>
                    <option value="BDSC → Union III">BDSC → Union III</option>
                  </select>
                  <button type="submit">Submit Request</button>
                </form>
                {/* Pending requests list for clients */}
                {pendingRequests.length > 0 && (
                  <div style={{ marginTop: '20px' }}>
                    <h4>Pending Requests</h4>
                    <table>
                      <thead>
                        <tr>
                          <th>Full Name</th>
                          <th>Position</th>
                          <th>Date</th>
                          <th>Time</th>
                          <th>Route</th>
                          <th>Status</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pendingRequests.map(req => (
                          <tr key={req.id}>
                            <td>{req.fullName}</td>
                            <td>{req.position}</td>
                            <td>{req.date}</td>
                            <td>{req.time}</td>
                            <td>{req.route}</td>
                            <td>{req.status}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'admin' && (
              <div>
                <h3>Admin Review</h3>
                {pendingRequests.length === 0 ? (
                  <p>No pending requests.</p>
                ) : (
                  <table>
                    <thead>
                      <tr>
                        <th>Full Name</th>
                        <th>Position</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>Route</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {pendingRequests.map(req => (
                        <tr key={req.id}>
                          <td>{req.fullName}</td>
                          <td>{req.position}</td>
                          <td>{req.date}</td>
                          <td>{req.time}</td>
                          <td>{req.route}</td>
                          <td>
                            <button onClick={() => approveRequest(req.id)}>Approve</button>
                            <button onClick={() => declineRequest(req.id)}>Decline</button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            )}

            {activeTab === 'users' && (
              <div>
                {/* Invite button aligned to the right */}
                <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '10px' }}>
                  <button onClick={() => setShowInviteForm(!showInviteForm)}>Invite</button>
                </div>
                {showInviteForm && (
                  <form onSubmit={handleInviteSubmit} style={{ marginBottom: '10px' }}>
                    <input
                      type="email"
                      placeholder="Email address"
                      value={inviteEmail}
                      onChange={e => setInviteEmail(e.target.value)}
                      required
                    />
                    <button type="submit">Send Invitation</button>
                  </form>
                )}
                {inviteMessage && <p style={{ marginBottom: '10px' }}>{inviteMessage}</p>}
                <table>
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Email</th>
                      <th>Role</th>
                    </tr>
                  </thead>
                  <tbody>
                    {usersList.map(u => (
                      <tr key={u.email}>
                        <td>{u.name || deriveName(u.email)}</td>
                        <td>{u.email}</td>
                        <td>{u.role}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {activeTab === 'agenda' && (
              <div>
                <h3>Agenda</h3>
                {scheduledMovements.length === 0 ? (
                  <p>No scheduled movements.</p>
                ) : (
                  <table>
                    <thead>
                      <tr>
                        <th>Full Name</th>
                        <th>Position</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>Route</th>
                        <th>Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      {scheduledMovements.map(mov => (
                        <tr key={mov.id}>
                          <td>{mov.fullName}</td>
                          <td>{mov.position}</td>
                          <td>{mov.date}</td>
                          <td>{mov.time}</td>
                          <td>{mov.route}</td>
                          <td>{mov.status}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            )}
          </div>
        );
      }
      // Render the application
      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Movement Scheduler with Supabase</title>
    <!--
      This version of the movement scheduler demonstrates how to persist data to
      a remote Supabase database instead of the browser's localStorage. The
      original app stored users, requests, movements and invitations directly
      in the user's browser. That meant each browser had its own copy of the
      data and an admin couldn't see requests created on another device. By
      moving persistence to Supabase we centralise our state so that every
      client sees the same information.  Use your own Supabase project URL
      and anon key below – you can find these in the Supabase dashboard. The
      Supabase JavaScript client is imported via CDN as described in the
      official documentation【830261165282000†L46-L63】.
    -->
    <style>
      /* Page layout */
      body {
        font-family: 'Poppins', sans-serif;
        margin: 0;
        padding: 40px 0;
        background: #f3f8fc;
        display: flex;
        justify-content: center;
      }
      /* Container centers all content */
      .container {
        width: 100%;
        max-width: 600px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        padding: 20px 30px;
        text-align: center;
      }
      /* Logos container styling */
      .logos {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-bottom: 20px;
      }
      .logos img {
        height: 60px;
      }
      /* Form and input styles */
      form {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
        margin-bottom: 20px;
        /* Narrow the form so fields are not overly wide */
        max-width: 320px;
        margin-left: auto;
        margin-right: auto;
      }
      input,
      select,
      button {
        padding: 10px;
        font-size: 14px;
        border-radius: 4px;
        border: 1px solid #e0e8f0;
      }
      button {
        background: #0070f3;
        color: #fff;
        border: none;
        cursor: pointer;
      }
      button:hover {
        background: #005bb5;
      }
      .tabs {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      .tabs button {
        flex: 1;
        padding: 10px;
        background: #e3effb;
        border: none;
        border-radius: 4px;
        font-weight: 600;
        cursor: pointer;
      }
      .tabs button.active {
        background: #0070f3;
        color: #fff;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th,
      td {
        padding: 8px;
        border: 1px solid #e0e8f0;
        font-size: 14px;
      }
      th {
        background: #e3effb;
        font-weight: 600;
      }
      /* Messages */
      .error {
        color: #c0392b;
        font-size: 14px;
      }
    </style>
    <!-- React and Supabase dependencies. We rely on the global `supabase`
         variable after loading the client via CDN as described in the Supabase
         docs【830261165282000†L46-L63】. -->
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body>
    <div class="container">
      <!-- Application root -->
      <div id="root"></div>
    </div>
    <script type="text/babel">
      // Replace the placeholders below with your Supabase project credentials.
      // You can create a new project at https://app.supabase.com and find
      // the anonymous public key in your project settings. The Supabase
      // client is created once and reused throughout the application.
      const { createClient } = supabase;
      const SUPABASE_URL = 'https://dpkegvaoldfkuorudnzy.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRwa2VndmFvbGRma3VvcnVkbnp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzNzM3MzIsImV4cCI6MjA3MDk0OTczMn0.5sCNX68dJ1ZHT0Wj_HH3HTLwqQzKO2gq_QPtFOXQ4eQ';
      const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
      
      // Hard-coded admin credentials. These are added to the database on
      // startup if no admin user exists. In a production system you'd want
      // to manage admins differently.
      const ADMIN_EMAIL = 'haider.sahib@greenzone-oasis.com';
      const ADMIN_PASSWORD = 'Npsfaa@k3s';

      // Derive a name from an email address by capitalising each segment
      const deriveName = email => {
        return email
          .split('@')[0]
          .split('.')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join(' ');
      };

      function App() {
        // Authentication and global state
        const [user, setUser] = React.useState(null);
        const [loginEmail, setLoginEmail] = React.useState('');
        const [loginPassword, setLoginPassword] = React.useState('');
        const [error, setError] = React.useState('');
        const [activeTab, setActiveTab] = React.useState('request');
        const [requests, setRequests] = React.useState([]);
        const [movements, setMovements] = React.useState([]);
        const [formData, setFormData] = React.useState({
          fullName: '',
          position: '',
          date: '',
          time: '',
          fromLocation: '',
          toLocation: ''
        });
        const [usersList, setUsersList] = React.useState([]);
        const [invites, setInvites] = React.useState([]);
        // Invitation form state
        const [showInviteForm, setShowInviteForm] = React.useState(false);
        const [inviteEmail, setInviteEmail] = React.useState('');
        const [inviteMessage, setInviteMessage] = React.useState('');
        // Sign‑up via invite state
        const [signUpPassword, setSignUpPassword] = React.useState('');
        const [signUpConfirm, setSignUpConfirm] = React.useState('');

        // If the URL contains ?invite=email@address then this is an invited
        // user attempting to set their password.
        const inviteEmailParam = React.useMemo(() => {
          const params = new URLSearchParams(window.location.search);
          return params.get('invite');
        }, []);

        // On first render fetch all persisted data from Supabase. Also ensure
        // that the admin user exists; if not, insert it. Because Supabase
        // operations are asynchronous, we wrap them in an async function.
        React.useEffect(() => {
          (async () => {
            try {
              // Check for an existing admin
              const { data: existingAdmin } = await db
                .from('users')
                .select('*')
                .eq('email', ADMIN_EMAIL)
                .maybeSingle();
              if (!existingAdmin) {
                await db.from('users').insert([
                  {
                    name: deriveName(ADMIN_EMAIL),
                    email: ADMIN_EMAIL,
                    password: ADMIN_PASSWORD,
                    role: 'admin'
                  }
                ]);
              }
              // Fetch all users
              const { data: userRows } = await db.from('users').select('*');
              setUsersList(userRows || []);
              // Fetch requests
              const { data: reqRows } = await db.from('requests').select('*');
              setRequests(reqRows || []);
              // Fetch movements
              const { data: movRows } = await db.from('movements').select('*');
              setMovements(movRows || []);
              // Fetch invites
              const { data: inviteRows } = await db.from('invites').select('*');
              setInvites(inviteRows || []);
            } catch (err) {
              console.error('Error initialising data', err);
            }
          })();
        }, []);

        // Handle login
        async function handleLogin(e) {
          e.preventDefault();
          setError('');
          const { data: foundUser } = await db
            .from('users')
            .select('*')
            .eq('email', loginEmail.trim().toLowerCase())
            .eq('password', loginPassword)
            .maybeSingle();
          if (foundUser) {
            setUser(foundUser);
            setLoginEmail('');
            setLoginPassword('');
            setActiveTab(foundUser.role === 'admin' ? 'admin' : 'request');
          } else {
            setError('Invalid credentials');
          }
        }

        // Logout simply clears the user state
        function logout() {
          setUser(null);
          setActiveTab('request');
        }

        // Handle changes in the request form
        function handleFormChange(e) {
          const { name, value } = e.target;
          setFormData(prev => ({ ...prev, [name]: value }));
        }

        // Submit a new movement request and persist to Supabase
        async function submitRequest(e) {
          e.preventDefault();
          // Build the request object without an id – Supabase will generate one
          const newReq = {
            fullName: formData.fullName,
            position: formData.position,
            date: formData.date,
            time: formData.time,
            fromLocation: formData.fromLocation,
            toLocation: formData.toLocation,
            status: 'pending'
          };
          const { data: inserted, error: insertErr } = await db
            .from('requests')
            .insert([newReq])
            .select();
          if (!insertErr && inserted && inserted.length > 0) {
            // Update local state with the new request
            setRequests(prev => [...prev, inserted[0]]);
            setFormData({
              fullName: '',
              position: '',
              date: '',
              time: '',
              fromLocation: '',
              toLocation: ''
            });
          } else {
            console.error('Failed to insert request', insertErr);
          }
        }

        // Approve a pending request: update its status and add it to movements
        async function approveRequest(id) {
          // Find the original request object in state
          const req = requests.find(r => r.id === id);
          if (!req) return;
          // Update request status in the database
          const { data: updatedReqs, error: updateErr } = await db
            .from('requests')
            .update({ status: 'approved' })
            .eq('id', id)
            .select();
          // Insert corresponding movement
          const movement = {
            fullName: req.fullName,
            position: req.position,
            date: req.date,
            time: req.time,
            fromLocation: req.fromLocation,
            toLocation: req.toLocation,
            status: 'scheduled'
          };
          const { data: insertedMov, error: movErr } = await db
            .from('movements')
            .insert([movement])
            .select();
          if (!updateErr && !movErr) {
            // Update local state
            setRequests(prev => prev.map(r => (r.id === id ? { ...r, status: 'approved' } : r)));
            if (insertedMov && insertedMov.length > 0) {
              setMovements(prev => [...prev, insertedMov[0]]);
            }
          } else {
            console.error('Approval error', updateErr || movErr);
          }
        }

        // Decline a pending request by updating its status
        async function declineRequest(id) {
          const { error: updateErr } = await db
            .from('requests')
            .update({ status: 'declined' })
            .eq('id', id);
          if (!updateErr) {
            setRequests(prev => prev.map(r => (r.id === id ? { ...r, status: 'declined' } : r)));
          } else {
            console.error('Decline error', updateErr);
          }
        }

        // Handle the admin sending an invitation. This writes a new invite row
        // and returns a link the admin can email to the prospective user.
        async function handleInviteSubmit(e) {
          e.preventDefault();
          setInviteMessage('');
          const email = inviteEmail.trim().toLowerCase();
          if (!email) {
            setInviteMessage('Please provide a valid email.');
            return;
          }
          // Check if user already exists
          const { data: existingUser } = await db
            .from('users')
            .select('id')
            .eq('email', email)
            .maybeSingle();
          if (existingUser) {
            setInviteMessage('User already exists.');
            setInviteEmail('');
            setShowInviteForm(false);
            return;
          }
          // Check if an invitation is already recorded
          const { data: existingInvite } = await db
            .from('invites')
            .select('id')
            .eq('email', email)
            .maybeSingle();
          if (existingInvite) {
            setInviteMessage('An invitation has already been sent to this email.');
            setInviteEmail('');
            setShowInviteForm(false);
            return;
          }
          // Record the invitation
          const { data: insertedInv, error: invErr } = await db
            .from('invites')
            .insert([{ email: email, invited: true }])
            .select();
          if (!invErr && insertedInv && insertedInv.length > 0) {
            setInvites(prev => [...prev, insertedInv[0]]);
            const linkQuery = '?invite=' + encodeURIComponent(email);
            const invitationLink = window.location.origin + linkQuery;
            setInviteMessage('Invitation recorded. Please email the recipient this link: ' + invitationLink);
            setInviteEmail('');
            setShowInviteForm(false);
          } else {
            console.error('Invite error', invErr);
          }
        }

        // Handle an invited user setting their password. Creates a new user and
        // deletes the invite.
        async function handleInviteSignup(e) {
          e.preventDefault();
          setError('');
          if (signUpPassword !== signUpConfirm) {
            setError('Passwords do not match');
            return;
          }
          const email = inviteEmailParam.trim().toLowerCase();
          // Ensure the user doesn't already exist
          const { data: existingUser } = await db
            .from('users')
            .select('*')
            .eq('email', email)
            .maybeSingle();
          if (existingUser) {
            setError('Account already exists. Please log in instead.');
            return;
          }
          const newUser = {
            name: deriveName(email),
            email: email,
            password: signUpPassword,
            role: 'client'
          };
          const { error: insertErr } = await db.from('users').insert([newUser]);
          if (!insertErr) {
            // Delete the invite
            await db.from('invites').delete().eq('email', email);
            // Redirect back to login
            window.location.href = window.location.origin;
          } else {
            console.error('Signup error', insertErr);
            setError('Error creating account');
          }
        }

        // Compute derived lists
        const pendingRequests = requests.filter(r => r.status === 'pending');
        const scheduledMovements = movements;

        // If the user is not logged in we show either the invitation sign‑up
        // form or the login form.
        if (!user) {
          if (inviteEmailParam) {
            return (
              <div>
                <h2>Set Your Password</h2>
                <p>Please set a password for your new account ({inviteEmailParam}).</p>
                <form onSubmit={handleInviteSignup}>
                  <input
                    type="password"
                    placeholder="Enter Password"
                    value={signUpPassword}
                    onChange={e => setSignUpPassword(e.target.value)}
                    required
                  />
                  <input
                    type="password"
                    placeholder="Re‑Enter Password"
                    value={signUpConfirm}
                    onChange={e => setSignUpConfirm(e.target.value)}
                    required
                  />
                  {error && <div className="error">{error}</div>}
                  <button type="submit">Set Password</button>
                </form>
              </div>
            );
          }
          return (
            <div>
              <h2>Login</h2>
              <form onSubmit={handleLogin}>
                <input
                  type="email"
                  placeholder="Email"
                  value={loginEmail}
                  onChange={e => setLoginEmail(e.target.value)}
                  required
                />
                <input
                  type="password"
                  placeholder="Password"
                  value={loginPassword}
                  onChange={e => setLoginPassword(e.target.value)}
                  required
                />
                {error && <div className="error">{error}</div>}
                <button type="submit">Login</button>
              </form>
            </div>
          );
        }

        // Build the tab bar based on the user's role
        const tabs =
          user.role === 'admin'
            ? [
                { id: 'admin', label: 'Admin Review' },
                { id: 'agenda', label: 'Agenda' },
                { id: 'users', label: 'Users' }
              ]
            : [
                { id: 'request', label: 'Request Movement' },
                { id: 'agenda', label: 'Agenda' }
              ];

        const displayName = user.name || deriveName(user.email);

        return (
          <div>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
              <h2>Welcome, {displayName}</h2>
              <button onClick={logout}>Log Out</button>
            </div>
            <div className="tabs">
              {tabs.map(tab => (
                <button
                  key={tab.id}
                  className={activeTab === tab.id ? 'active' : ''}
                  onClick={() => setActiveTab(tab.id)}
                >
                  {tab.label}
                </button>
              ))}
            </div>

            {activeTab === 'request' && (
              <div>
                <h3>Request Movement</h3>
                <form onSubmit={submitRequest}>
                  <input
                    type="text"
                    name="fullName"
                    placeholder="Full Name"
                    value={formData.fullName}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="text"
                    name="position"
                    placeholder="Position"
                    value={formData.position}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="date"
                    name="date"
                    value={formData.date}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="time"
                    name="time"
                    value={formData.time}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="text"
                    name="fromLocation"
                    placeholder="From (e.g. BEC)"
                    value={formData.fromLocation}
                    onChange={handleFormChange}
                    required
                  />
                  <input
                    type="text"
                    name="toLocation"
                    placeholder="To (e.g. BDSC)"
                    value={formData.toLocation}
                    onChange={handleFormChange}
                    required
                  />
                  <button type="submit">Submit Request</button>
                </form>
                {/* Pending requests list for clients */}
                {pendingRequests.length > 0 && (
                  <div style={{ marginTop: '20px' }}>
                    <h4>Pending Requests</h4>
                    <table>
                      <thead>
                        <tr>
                          <th>Full Name</th>
                          <th>Position</th>
                          <th>Date</th>
                          <th>Time</th>
                          <th>From</th>
                          <th>To</th>
                          <th>Status</th>
                        </tr>
                      </thead>
                      <tbody>
                        {pendingRequests.map(req => (
                          <tr key={req.id}>
                            <td>{req.fullName}</td>
                            <td>{req.position}</td>
                            <td>{req.date}</td>
                            <td>{req.time}</td>
                            <td>{req.fromLocation}</td>
                            <td>{req.toLocation}</td>
                            <td>{req.status}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </div>
            )}

            {activeTab === 'admin' && (
              <div>
                <h3>Admin Review</h3>
                {pendingRequests.length === 0 ? (
                  <p>No pending requests.</p>
                ) : (
                  <table>
                    <thead>
                      <tr>
                        <th>Full Name</th>
                        <th>Position</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>From</th>
                        <th>To</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {pendingRequests.map(req => (
                        <tr key={req.id}>
                          <td>{req.fullName}</td>
                          <td>{req.position}</td>
                          <td>{req.date}</td>
                          <td>{req.time}</td>
                          <td>{req.fromLocation}</td>
                          <td>{req.toLocation}</td>
                          <td>
                            <button onClick={() => approveRequest(req.id)}>Approve</button>
                            <button onClick={() => declineRequest(req.id)}>Decline</button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            )}

            {activeTab === 'users' && (
              <div>
                {/* Invite button aligned to the right */}
                <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '10px' }}>
                  <button onClick={() => setShowInviteForm(!showInviteForm)}>Invite</button>
                </div>
                {showInviteForm && (
                  <form onSubmit={handleInviteSubmit} style={{ marginBottom: '10px' }}>
                    <input
                      type="email"
                      placeholder="Email address"
                      value={inviteEmail}
                      onChange={e => setInviteEmail(e.target.value)}
                      required
                    />
                    <button type="submit">Send Invitation</button>
                  </form>
                )}
                {inviteMessage && <p style={{ marginBottom: '10px' }}>{inviteMessage}</p>}
                <table>
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Email</th>
                      <th>Role</th>
                    </tr>
                  </thead>
                  <tbody>
                    {usersList.map(u => (
                      <tr key={u.email}>
                        <td>{u.name || deriveName(u.email)}</td>
                        <td>{u.email}</td>
                        <td>{u.role}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {activeTab === 'agenda' && (
              <div>
                <h3>Agenda</h3>
                {scheduledMovements.length === 0 ? (
                  <p>No scheduled movements.</p>
                ) : (
                  <table>
                    <thead>
                      <tr>
                        <th>Full Name</th>
                        <th>Position</th>
                        <th>Date</th>
                        <th>Time</th>
                        <th>From</th>
                        <th>To</th>
                        <th>Status</th>
                      </tr>
                    </thead>
                    <tbody>
                      {scheduledMovements.map(mov => (
                        <tr key={mov.id}>
                          <td>{mov.fullName}</td>
                          <td>{mov.position}</td>
                          <td>{mov.date}</td>
                          <td>{mov.time}</td>
                          <td>{mov.fromLocation}</td>
                          <td>{mov.toLocation}</td>
                          <td>{mov.status}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            )}
          </div>
        );
      }
      // Render the application
      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>
